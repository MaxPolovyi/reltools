#!/usr/bin/env python
import os
import signal
import sys
import time
import daemon 
import datetime
import re
import json
import subprocess
from optparse import OptionParser
ASICD_CONF_FILE='/opt/flexswitch/params/asicd.conf'

nonSnapRouteDmns = {
    'sqlwebd' : '/usr/local/bin/sqlite_web'
}
def determineMacAddress ():
    print 'Getting MAC address'
    process = subprocess.Popen('ifconfig -a' ,
                                shell=True,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
    out, err = process.communicate()
    errcode = process.returncode
    macAddrList = []
    macAddrCopy = []
    for line in out.split('\n'):
        if re.search('HWaddr', line):
           addr = line.partition('HWaddr')[-1].strip(' ')
           port = line.split()[0]
           if addr not in macAddrCopy and not (port.startswith('SVI') or port.startswith('bcm') or port.startswith('fpPort')):
               macAddrList.append((port, addr))
               macAddrCopy.append(addr)
    chosenMac = macAddrList[0][1]
    newMac = '%x' %(int(chosenMac.replace(':',''), 16))
    returnMac = int(newMac, 16) +1
    returnMacStr = '%x' %(returnMac)
    returnMacStr = '%s' %(returnMacStr.zfill(12))
    resultMacStr = ''.join([c+':' if i%2 and i <len(returnMacStr)-1 else c for i,c in enumerate(returnMacStr)])
    if os.path.isfile(ASICD_CONF_FILE) :
        with open(ASICD_CONF_FILE, 'r') as fileHdl:
            confData = json.load(fileHdl)
            confData['SwitchMac'] = resultMacStr
        with open(ASICD_CONF_FILE, 'w') as fileHdl:
            json.dump(confData, fileHdl,  indent=2)

def isProcessRunning(pidFile):
    processId = 0
    try:
        fp = file(pidFile, "r")
        processId = int(fp.read().strip())
        fp.close()
        if os.path.exists('/proc/%d' % processId):
            pass
        else:
            processId = 0
    except IOError:
        processId = 0
    return (processId != 0)

def getDaemonsInfo (baseDir) :

    daemonsToStart = [
                    {'name': 'asicd',
                     'params': '-params=' + baseDir + '/params'},

                    {'name': 'sysd',
                     'params': '-params=' + baseDir + '/params'},

                    {'name': 'ribd',
                     'params': '-params=' + baseDir + '/params'},

                    {'name': 'bfdd',
                    'params': '-params=' + baseDir + '/params'},

                    {'name': 'arpd',
                     'params': '-params=' + baseDir + '/params'},

                    {'name': 'bgpd',
                     'params': '-params=' + baseDir + '/params'},

                    {'name': 'ospfd',
                     'params': '-params=' + baseDir + '/params'},

                    {'name': 'lacpd',
                    'params': '-params=' + baseDir + '/params'},
                    
                    {'name': 'dhcprelayd',
                    'params': '-params=' + baseDir + '/params'},

                    {'name': 'stpd',
                    'params': '-params=' + baseDir + '/params'},

                    {'name': 'vrrpd',
                     'params': '-params=' + baseDir + '/params'},
                    
		    {'name': 'confd',
                     'params': '-params=' + baseDir + '/params'},

                    {'name': 'sqlwebd',
                     'params': ['', '--port=8000 ' , '--host=0.0.0.0 ' ,  baseDir + '/params/UsrConfDb.db']},
                    ]
    return daemonsToStart

class FlexSwitchDaemon (daemon.Daemon):
    def run(self, *args, **kwargs):
        cmd = args[0][0]
        if type(args[0][1]) ==list:
	   pargs = args[0][1]	
	else :
	   pargs = args[0]
	
        os.execvp(cmd, pargs)


if __name__=="__main__":
    parser = OptionParser()

    parser.add_option("-d", "--dir", 
                      dest="directory",
                      action='store',
                      help="Directory where the binaries are stored")

    parser.add_option("-o", "--op", 
                      dest="op",
                      default="start",
                      action='store',
                      help="Operation (start/stop) ")

    parser.add_option("-b", "--boot",
                      dest="boot",
                      action='store',
                      help="Type of subsequent boot operation (cold/warm) ")

    (opts, args) = parser.parse_args()
    localBld = False
    if opts.directory != None:
        localBld = True
        baseDir = opts.directory 
    else:
        baseDir = "/opt/flexswitch"

    if opts.op != None and opts.op not in ['start', 'stop']:
        parser.print_usage()
        sys.exit(0)

    if opts.boot != None and opts.boot not in ['cold', 'warm']:
        parser.print_usage()
        sys.exit(0)

    if opts.op != 'stop' and opts.boot != None:
        parser.print_usage()
        sys.exit(0)
 
    if not localBld:
        determineMacAddress()
    pidFileDir = baseDir+'/bin/pids/'
    asicdBootModeFile = baseDir + '/params/asicdBootMode.conf'
    if opts.boot != None and opts.boot == 'cold':
        asicdBootMode = '0'
    else:
        asicdBootMode = '0' #FIXME:Change this to 1, when we start supporting restart on all apps

    if opts.op == 'start':
        if ((not os.path.exists(pidFileDir))):
            os.makedirs(pidFileDir)

        start = datetime.datetime.now()
        dmnCount = 0
        for dmn in getDaemonsInfo(baseDir):
            print "Starting Daemon %s Params: %s" %( dmn['name'], dmn['params'])
            dmnCount += 1
            pidFile = pidFileDir + dmn['name']+'.pid'
            if isProcessRunning(pidFile):
                print "process %s is already running" %(dmn['name'])
            else:
                if dmn['name'] not in nonSnapRouteDmns:
                    cmd = baseDir +'/bin/'+ dmn['name']
                else:
                    cmd = nonSnapRouteDmns[dmn['name']]

                pargs = (cmd, dmn['params'])
                time.sleep(2)
                pid = os.fork()
                if pid == 0:
                    dmnInst = FlexSwitchDaemon (pidFile,
                                            #stdout= baseDir+'/bin/'+'log.txt',
                                            #stderr= baseDir+'/bin/'+'log.txt',
                                            stdout = '/var/log/syslog',
                                            stderr = '/var/log/syslog',
                                            #stderr= baseDir+'/bin/'+'log.txt',
                                            verbose=2)
                    dmnInst.start(pargs)
        end = datetime.datetime.now()
        print 'Total time taken to start all %s daemons is  %s' %(dmnCount, end -start)
    else:
        for dmn in getDaemonsInfo(baseDir):
            try:
                print "Stopping Daemon %s" %( dmn['name'])
                pidFile = pidFileDir + dmn['name']+'.pid'
                pf = file(pidFile, 'r')
                pid = int(pf.read().strip())
                pf.close()
                try :
                    #Check if process matching pid file is running
                    os.kill(pid, 0)
                except:
                    #Process with pid not running, cleanup pid file
                    os.remove(pidFile)
                    continue
                #Process matching pid exists, perform cleanup
                if dmn['name'] == 'asicd':
                    if os.path.exists(asicdBootModeFile):
                        os.remove(asicdBootModeFile)
                    if opts.boot == 'cold':
                        os.kill(pid, signal.SIGUSR1)
                    else:
                        os.kill(pid, signal.SIGUSR1) #FIXME:Change this to SIGHUP, when we start supporting restart on all apps
                    f = open(asicdBootModeFile, 'w')
                    f.write(asicdBootMode)
                    f.close()
                else:
                    os.kill(pid, signal.SIGHUP)
            except:
                print '*** Failed to stop process [%s]' %(dmn['name'])
        time.sleep(10)
        for dmn in getDaemonsInfo(baseDir if not localBld else baseDir+'/bin'):
            try:
                pidFile = pidFileDir + dmn['name']+'.pid'
                try :
                    #Check if cleanup completed
                    os.kill(pid, 0)
                except:
                    #Process with pid successfully cleaned up
                    os.remove(pidFile)
                    continue
                    #Force kill by sending SIGTERM
                    os.kill(pid, signal.SIGTERM)
                    os.remove(pidFile)
            except:
                print '*** Failed to Kill process [%s]' %(dmn['name'])
